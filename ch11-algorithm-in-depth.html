<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js rust">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Algorithm In-Depth - broccoli_report</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "rust";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="overview.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="ch0-analysis-method.html"><strong aria-hidden="true">2.</strong> Analysis Method</a></li><li class="chapter-item expanded "><a href="ch1-broccoli-vs-other.html"><strong aria-hidden="true">3.</strong> Comparison to other Algs</a></li><li class="chapter-item expanded "><a href="ch2-construction-vs-query.html"><strong aria-hidden="true">4.</strong> Construction vs Query</a></li><li class="chapter-item expanded "><a href="ch3-level-analysis.html"><strong aria-hidden="true">5.</strong> Tree Level Load</a></li><li class="chapter-item expanded "><a href="ch4-aabb-data-layout.html"><strong aria-hidden="true">6.</strong> AABB Data Layout</a></li><li class="chapter-item expanded "><a href="ch5-tree-data-layout.html"><strong aria-hidden="true">7.</strong> Tree Data Layout</a></li><li class="chapter-item expanded "><a href="ch6-choosing-optimal-height.html"><strong aria-hidden="true">8.</strong> Optimal Tree Height</a></li><li class="chapter-item expanded "><a href="ch7-parallelism.html"><strong aria-hidden="true">9.</strong> Parallelism</a></li><li class="chapter-item expanded "><a href="ch8-bounds-checking.html"><strong aria-hidden="true">10.</strong> Bounds Checking</a></li><li class="chapter-item expanded "><a href="ch9-primitive-types.html"><strong aria-hidden="true">11.</strong> Primitive Types</a></li><li class="chapter-item expanded "><a href="ch10-api-design.html"><strong aria-hidden="true">12.</strong> API Design</a></li><li class="chapter-item expanded "><a href="ch11-algorithm-in-depth.html" class="active"><strong aria-hidden="true">13.</strong> Algorithm In-Depth</a></li><li class="chapter-item expanded "><a href="ch12-improvements.html"><strong aria-hidden="true">14.</strong> Improvements</a></li><li class="chapter-item expanded "><a href="ch13-how-to-make-aabb.html"><strong aria-hidden="true">15.</strong> How to make Aabb</a></li><li class="chapter-item expanded "><a href="ch14-code-layout.html"><strong aria-hidden="true">16.</strong> Code Layout</a></li><li class="chapter-item expanded "><a href="ch15-general-thoughts.html"><strong aria-hidden="true">17.</strong> General Thoughts</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">broccoli_report</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h3><a class="header" href="#algorithm-overview" id="algorithm-overview">Algorithm overview:</a></h3>
<h4><a class="header" href="#construction" id="construction">Construction</a></h4>
<p>Construction works as follows, Given: a list of elements.</p>
<p>For every node we do the following:</p>
<ol>
<li>First we find the median of the remaining elements (using pattern defeating quick select) and use its position as this nodes divider.</li>
<li>Then we bin the aabbs into three bins. Those strictly to the left of the divider, those strictly to the right, and those that intersect.</li>
<li>Then we sort the aabbs that intersect the divider along the opposite axis that was used to finding the median. These aabbs now live in this node.</li>
<li>Now this node is fully set up. Recurse left and right with the aabbs that were binned left and right. This can be done in parallel.</li>
</ol>
<h4><a class="header" href="#finding-all-colliding-pairs" id="finding-all-colliding-pairs">Finding all colliding pairs</a></h4>
<p>Done via divide and conquer. For every node we do the following:</p>
<ol>
<li>First we find all intersections with aabbs in that node using sweep and prune..</li>
<li>We recurse left and right finding all aabbs that intersect with aabbs in the node.
Here we can quickly rule out entire nodes and their decendants if a node's aabb does not intersect
with this nodes aabb.</li>
<li>At this point the aabbs in this node have been completely handled. We can safely move on to the children nodes 
and treat them as two entirely seperate trees. Since these are two completely disjoint trees, they can be handling in
parallel.</li>
</ol>
<h4><a class="header" href="#allocations" id="allocations">Allocations</a></h4>
<p>There are some very fast allocators out
there, but not all allocators are created equal. If you want your code to be as platform independant as possible,
you should try to minimize allocations even if in benches on your local machine, there is no performance hit. For example, currently the rust webassembly target using a very simple allocator that is pretty slow. The colliding pair
finding algorithm requires a stack at each level of recursion. Each level of recursion, we could allocate a new stack,
but reusing the preallocated stack is better. It just turns out that this requires some unsafe{} since we are poulating the stack with lifetimed mutable references. </p>
<h4><a class="header" href="#how-to-handle-parallel-cases" id="how-to-handle-parallel-cases">How to handle parallel cases</a></h4>
<p>Part of the colliding pair finding algorithm requires that we find all colliding pairs between two nodes. 
Some times the aabbs between two nodes are sorted along the same dimension and sometimes not. When they are
we have three options that all sound pretty good:</p>
<ul>
<li>Option 1:
<ul>
<li>Use just one stack of active list</li>
<li>Aabbs are kept in the active list longer than normal</li>
<li>More comparisons, but simple and only uses one vec</li>
</ul>
</li>
<li>Option 2:
<ul>
<li>Use two active lists. </li>
<li>Fewest comparisons</li>
<li>Needs two vecs.</li>
</ul>
</li>
<li>Option 3:
<ul>
<li>Use two active lists, but implement it as one vec under the hood.</li>
<li>Fewest allocations</li>
<li>Fewest comparisons</li>
<li>Slow to push and truncate each vec since it requires shuffling things around.</li>
</ul>
</li>
</ul>
<p>I went with option 3. The performance hit from pushing and truncating can be made up with a big allocation up front.
Doing two big allocations upfront for option2 is wasteful.</p>
<h4><a class="header" href="#how-to-speed-up-perpendicular-cases" id="how-to-speed-up-perpendicular-cases">How to speed up perpendicular cases</a></h4>
<p>Its slow to naively find intersections between the aabbs in two nodes that are sorted along different dimensions.
There are a couple of options:</p>
<ul>
<li>
<p>Option 1:</p>
<ul>
<li>Cut off each list by using the other node's bounding box to deal with smaller lists.</li>
<li>Now iterate over each element, and perform parallel sweep where one list has size one.</li>
</ul>
</li>
<li>
<p>Option 2:</p>
<ul>
<li>Cut off each list by using the other node's bounding box to deal with smaller list.</li>
<li>Collect a list of pointers of one list. </li>
<li>Sort that list along the other lists axis</li>
<li>Perform parallel sweep </li>
</ul>
</li>
<li>
<p>Option 3:</p>
<ul>
<li>Cut off each list as always</li>
<li>do a simple nested loop and check if the aabbs intersect</li>
</ul>
</li>
<li>
<p>Option 4:</p>
<ul>
<li>Cut off each list as always</li>
<li>For each element in node A, iterate over each element in node B.
<ul>
<li>Exit early if the B element is completely to the right of the A element.</li>
<li>Now we only have to check if the B element's right side is touching A.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Option 4 is the fastest. It exploits the sorted property of the aabbs, but also does not require
any kind of storage of an active list.</p>
<h4><a class="header" href="#profiling-construction--finding-all-colliding-pairs" id="profiling-construction--finding-all-colliding-pairs">Profiling Construction + Finding all colliding pairs.</a></h4>
<p>Here are some profiling results finding all intersections on <code>abspiral(0.2,50_000)</code> 30 times. 
The image below is a SVG image and is interactive. Hover over blocks to see the full names.
Try this link for a full page view of the image (or if it is not rendering correctly): <a href="graphs/flamegraph.svg">SVG</a></p>
<object class="p" data="graphs/flamegraph.svg" type="image/svg+xml" style="width: 100%;">
</object>
<p>The flame graph shows a very insightful map of how much time is spent in which sections of the algorithm.
You can clearly see how the rebalancing and the querying are each individually broken down.
You can see how at each recursive step, a piece of the problem is broken off.</p>
<h4><a class="header" href="#nbody-experimental" id="nbody-experimental">nbody (experimental)</a></h4>
<p>Here we use divide and conquer.</p>
<p>The nbody algorithm works in three steps. First a new version tree is built with extra data for each node. Then the tree is traversed taking advantage of this data. Then the tree is traversed again applying the changes made to the extra data from the construction in the first step.</p>
<p>The extra data that is stored in the tree is the sum of the masses of all the aabbs in that node and all the aabbs under it. The idea is that if two nodes are sufficiently far away from one another, they can be treated as a single body of mass.</p>
<p>So once the extra data is setup, for every node we do the following:
Gravitate all the aabbs with each other that belong to this node.
Recurse left and right gravitating all aabbs encountered with all the aabbs in this node.
Here once we reach nodes that are sufficiently far away, we instead gravitate the node's extra data with this node's extra data, and at this point we can stop recursing.
At this point it might appear we are done handling this node and the problem has been reduced to two smaller ones, but we are not done yet. We additionally have to gravitate all the aabbs on the left of this node with all the aabbs on the right of this node.
For all nodes encountered while recursing the left side,
Recurse the right side, and handle all aabbs with all the aabbs on the left node.
If a node is suffeciently far away, treat it as a node mass instead and we can stop recursing.
At this point we can safely exclude this node and handle the children and completely independent problems.</p>
<h4><a class="header" href="#raycasting" id="raycasting">Raycasting</a></h4>
<p>TODO explain now</p>
<p>TODO improvement:
right now the raycast algorithm naively checks all the elements that belong to a node provided
it decides to look at a node. In reality, we could do better. We could figure out where the ray
hits the divider line, and then only check AABBs that intersect that divider line. The problem
with this improvement is that we can't just rely on the <code>Num</code> trait since we need to do some math.
You lose the nice property of the algorithm not doing any number arithmatic. Therefore I didnt implement
it. However it might be a good idea. That said, before any element is checked using the expensive raycast function, it will first check the abb
raycast function to determine if it is even worth going further. This is probably a good enough speed up.</p>
<h4><a class="header" href="#knearest" id="knearest">Knearest</a></h4>
<p>TODO explain</p>
<h4><a class="header" href="#rect" id="rect">Rect</a></h4>
<p>TODO explain.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="ch10-api-design.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="ch12-improvements.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="ch10-api-design.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="ch12-improvements.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        
        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3000/__livereload");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
